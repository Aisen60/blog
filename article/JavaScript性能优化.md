### 内存管理

**内存管理是什么？**

顾名思义内存管理就是对内存进行管理，和其它语言不一样的是，js 中底层没有提供内存管理的接口。js 在创建变量的时候就自动分配了内存，并且在这些变量不再使用的时候自动清除，这个过程也叫做**垃圾回收**。

**为什么需要内存管理**

随着目前前端项目越来越庞大，工程化越来越复杂，我们更加需要对内存进行管理。如果不进行内存管理，我们的程序会越用越卡，甚至会崩溃，造成的体验会很不友好。

**js 中的内存管理**

js 中的内存管理分为三步：

- 申请内存空间
- 使用内存空间
- 释放内存空间

**申请内存空间、使用内存空间**

因为 js 没有提供内存管理的接口，所以 js 在创建变量的时候，自动就分配了内存空间，或者说自动申请到了内存空间。当把一个值赋值给变量`a`的时候，那么可以说是 a 使用了内存空间。

```javaScript
var a;
a = 'xxx'
```

**释放内存空间**

当变量不在被使用到的时候，那么`a`就会被释放掉或者说被自动清除，这个过程也叫做**垃圾回收**

```javaScript
function fn(){
    var a = '1'; // a 是一个局部变量，当调用完fn后，这个变量就没有被用到了，就会被清除掉，或者说这个内存被释放了
    console.log(a)
}
fn()
```

#### 引用计数算法原理

引用计算算法的核心思想是：每一个对象都有一个计数器，这个计数器被用来存储对象的引用次数的，每当对象的引用关系发生改变时，计数器也会发生改变，当计数器为**0**的时候，则被视为垃圾，回收其内存空间。

这篇文章介绍的很清楚，可以看看。[GC 之引用计数算法](https://blog.csdn.net/weixin_43738058/article/details/101379748)

**引用计数算法优点**

- 发现垃圾时立即回收
- 最大限度减少程序暂停

**引用计数算法缺点**

- 无法回收循环引用的对象
- 时间开销大

#### 标记清除算法

标记清除算法是由标记阶段和清除阶段构成。标记阶段会遍历所有活动对象都坐上标记的阶段。清除阶段是遍历那些没有标记的对象，也就是非活动对象回收的阶段，然后将非活动对象回收其内存空间。

**标记清除算法优点**

- 可以循环回收引用的对象
- 实现简单

**标记清除算法缺点**

- 容易产生碎片化空间，浪费空间。
- 不会立即回收垃圾对象。

#### 标记整理算法

标记整理算法的实现原理：和标记清除算法一样，在 V8 中这个算法也会被频繁的使用到。标记整理算法可以看做是标记清除的增强操作，在第一个阶段中和标记清除算法一样，会遍历所有活动对象,把当前可达对象进行标记。不过，在清除阶段，标记清除会把没有标记的对象做回收，但是，标记整理在回收之前，会先去执行一个整理移动的操作，并且让它们能在地址上产生连续。

**通过图示进行说明**

- 回收前

  在回收之前会做一个整理移动的操作，下面这个图是准备回收前，对象在内存中的位置。

  ![image](https://user-images.githubusercontent.com/19791710/83937069-1b4f4b00-a7fc-11ea-9df8-fead5e157c2c.png)

- 整理后

  这里整理的是将所有活动对象进行一个移动，将地址整理成一个连续的位置。紧接着把非活动对象以及一些没有用到的空间整理成一块。就是把用到的和没用到的区分开来，变成左右两边，左边就是活动对象，右边就是非活动对象和空的空间。接着会把右侧的进行回收

  ![image](https://user-images.githubusercontent.com/19791710/83937219-86e5e800-a7fd-11ea-9e2e-c96fba467d8d.png)

- 回收后

  回收完成后会得到这样的一个情况，那这种情况会比之前的标记清除的好处是，不会出现大批量的分散的内存空间。而回收到的空间基本上都是连续的。在后面的使用中，当我们去申请内存空间的时候，会最大化的利用我们内存中所释放出来的空间。

  ![image](https://user-images.githubusercontent.com/19791710/83937293-f22fba00-a7fd-11ea-9fc2-e36482efad3f.png)

### V8 引擎

#### V8 介绍

- V8 是一款主流的 `JavaScript` 执行引擎
- V8 采用即时编译，它的速度很快
- V8 内存设限，一般在 64 位的操作系统，这个上限一般不超过 1.5G，在 32 位的操作系统上，一般是 800M。

#### V8 垃圾回收策略

- 采用分代回收的思想
- 内存分为新生代、老生代
- 针对不同对象采用不同算法

V8 垃圾回收策略图示：

![image](https://user-images.githubusercontent.com/19791710/83937674-864f5080-a801-11ea-8798-9cc608f4d747.png)

#### V8 中常用的 GC 算法

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

V8 的内存是有上限的，基于这样的条件，要采用分代回收的思路，不同代的对象采用更加适合的 GC 算法，从而去实现 V8 的高效回收操作

#### V8 中的内存分配

![image](https://user-images.githubusercontent.com/19791710/83938153-bfd58b00-a804-11ea-8fde-15cd1d182560.png)

- V8 将内存一分为二
- 小空间（左边）用于存储新生代的对象，在 64 位操作系统中，一般为 32M，在 32 位操作系统中一般为 16M。
- 大空间（右边）用于存储老生代的对象，在 64 位操作系统中，一般为 1.4G，在 32 位操作系统中一般为 700M。

#### V8 如何回收新生代对象

**新生代指的是什么？**

新生代指的是存活时间比较短的对象。

新生代在内存区分为二个等大小的空间。

使用空间为`Form`，空闲空间为`To`，活跃对象存储在`Form`空间。

**新生代对象回收实现**

新生代在内存区域一分为二，这两个区域是等大小的，并且起名为`Form`和`To`。

然后，采用标记整理的算法，对当前`Form`活动空间进行标记整理操作，接着将`Form`空间拷贝至`To`空间，最后置换一下两个空间，原来的`Form`就变成了`To`，原来的`To`就变成了`Form`，此时也完成了空间的释放操作。

#### V8 如何回收老生代对象

**老生代指的是什么？**

老生代对象指的是存活时间较长的对象。

老对象生代存放在右侧老生代区域。

**老生代对象回收实现？**

- 主要采用标记清除、标记整理、增量标记算法。
- 首先采用标记清除完成垃圾空间的回收。
- 采用标记整理进行空间优化。当新生代晋升到老生代的时候，老生代对象空间不够新生代存所要晋升放空间的时候，就会进行标记整理算法。
- 采用增量标记进行效率优化。

**标记增量如何优化垃圾回收？**

![image](https://user-images.githubusercontent.com/19791710/83938800-15f8fd00-a80a-11ea-836c-95107fc4bd06.png)

当垃圾回收进行工作时，会阻塞 javaScript 线程的，当程序执行到需要回收垃圾的时候，标记增量就会开始工作。

标记增量的工作原理就是，将当前垃圾回收的操作，拆分成多个步骤进行，组合的完成垃圾回收，从而去替代之前一口气的垃圾回收操作。

这样做的好处是，可以让程序和垃圾回收交替完成。
